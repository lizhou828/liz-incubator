## 类加载器

    jvm允许开发人员自定义类加载器，以便让应用程序自己决定如何去获取所需的二进制流！
    这是一项创新，是为了Java Applet创造的，不过Java Applet已经死掉，但自定义类加载器却在类层次划分，代码加密，远程调用等方面大放异彩。可以说是失之桑榆，收之东偶。

### 类与类加载器

    两个类相同的条件是，同一个类加载器，相同的全限定名。即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就不相等。
    这两个所指的"相等"包括代表Class对象的equals(),isAssignableFrom(),和isInstance()方法，也包括使用instanceof关键字做对象所属关系的判定。




### 双亲委派模型

java虚拟机有两种类加载器，一种是启动类加载器(Bootstrap ClassLoad)，这个类加载器在jvm内部，由c++实现。
另一种就是其他的类加载器，这些类加载器使用Java实现，独立于虚拟机外部，并且全部继承于抽象类java.lang.ClassLoad

    启动类加载器，加载$JAVA_HOME/jre/lib下的目录，rt.jar就在这个目录下
    扩展类加载器，由sun.misc.Launcher$ExtClassLoader实现，负责加载$JAVA_HOME/jar/lib/ext目录下的类
    应用程序类加载器，这个类加载器负责加载用户类路径上所指定的类库
    
类加载器的这种层次关系被称为双亲委派模型，这里的父子类加载器不是以继承的关系来实现爱你的，而是以组合的关系实现的。
每个类加载器在加载类时，都先让父加载器加载，如果不在父加载器的范围内，父加载器不加载，这时子加载器才自己加载
使用双亲委派模型的好处就是java类之间有一种层级关系，rt.jar中的类必须被启动类扩展器加载，而不能被别的类加载器加载！双亲委派模型对于保证Java程序的稳定运作很重要！


###　"被破坏"的双亲委派模型

    有三种情况：

    * ClassLoad的产生时间早于双亲委派模型的产生时间，所以在早期都不遵守双亲委派模型。考虑到兼容性，至今loadCload()方法至今都是能够重写的，其实我们应该重写findClass()方法，来保证双亲委派模型。
    * 存在与rt.jar中的JNDI，JDBC等服务需要调用用户的业务类，所以不得已才允许父加载器要求子加载器加载类的情况，线程上下文的类加载器就是用于这种情况的！
    * 因为业界强烈要求实现热加载，实现模块化，所以有了OSGI，热加载就是使用了类加载机制，通过在程序运行时，替换类加载器来做到的，不过这样破坏了双亲委派模型
    
    被破坏不一定是坏的，这里的OSGI就很好，不过存在争议，并且Java9也更新了，其主打的就是模块化。